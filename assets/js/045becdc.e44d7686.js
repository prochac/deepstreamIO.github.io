"use strict";(self.webpackChunkdeepstreamio_github_io=self.webpackChunkdeepstreamio_github_io||[]).push([[2405],{3905:function(e,t,a){a.d(t,{Zo:function(){return s},kt:function(){return u}});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),d=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,c=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),p=d(a),u=n,h=p["".concat(c,".").concat(u)]||p[u]||m[u]||l;return a?r.createElement(h,i(i({ref:t},s),{},{components:a})):r.createElement(h,i({ref:t},s))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var d=2;d<l;d++)i[d]=a[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},3133:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return s},default:function(){return p}});var r=a(7462),n=a(3366),l=(a(7294),a(3905)),i=["components"],o={title:"Record Factory",description:"This class gives you access to all methods related to data-sync"},c=void 0,d={unversionedId:"docs/client-js/datasync-client-record",id:"docs/client-js/datasync-client-record",title:"Record Factory",description:"This class gives you access to all methods related to data-sync",source:"@site/docs/10-docs/20-client-js/80-datasync-client-record.md",sourceDirName:"10-docs/20-client-js",slug:"/docs/client-js/datasync-client-record",permalink:"/docs/docs/client-js/datasync-client-record",editUrl:"https://github.com/deepstreamIO/deepstreamIO.github.io/docs/10-docs/20-client-js/80-datasync-client-record.md",tags:[],version:"current",sidebarPosition:80,frontMatter:{title:"Record Factory",description:"This class gives you access to all methods related to data-sync"},sidebar:"tutorialSidebar",previous:{title:"Record",permalink:"/docs/docs/client-js/datasync-record"},next:{title:"Anonymous Record",permalink:"/docs/docs/client-js/datasync-anonymous-record"}},s=[{value:"Prerequisite",id:"prerequisite",children:[],level:2},{value:"Methods",id:"methods",children:[{value:"client.record.getRecord(name)",id:"clientrecordgetrecordname",children:[],level:3},{value:"client.record.getList(name)",id:"clientrecordgetlistname",children:[],level:3},{value:"client.record.getAnonymousRecord()",id:"clientrecordgetanonymousrecord",children:[],level:3},{value:"client.record.names()",id:"clientrecordnames",children:[],level:3},{value:"client.record.has(name, callback | Promise)",id:"clientrecordhasname-callback--promise",children:[],level:3},{value:"client.record.head(name, callback | Promise)",id:"clientrecordheadname-callback--promise",children:[],level:3},{value:"client.record.snapshot(name, callback | Promise)",id:"clientrecordsnapshotname-callback--promise",children:[],level:3},{value:"client.record.setData(name, path, data, callback)",id:"clientrecordsetdataname-path-data-callback",children:[],level:3},{value:"client.record.setDataWithAck(name, path, data)",id:"clientrecordsetdatawithackname-path-data",children:[],level:3},{value:"client.record.listen(pattern, callback)",id:"clientrecordlistenpattern-callback",children:[],level:3},{value:"client.record.unlisten(pattern)",id:"clientrecordunlistenpattern",children:[],level:3},{value:"client.record.notify(recordNames, callback? | Promise)",id:"clientrecordnotifyrecordnames-callback--promise",children:[],level:3},{value:"client.record.setMergeStrategy (recordName, mergeStrategy)",id:"clientrecordsetmergestrategy-recordname-mergestrategy",children:[],level:3},{value:"client.record.setMergeStrategyRegExp (pattern, mergeStrategy)",id:"clientrecordsetmergestrategyregexp-pattern-mergestrategy",children:[],level:3},{value:"client.record.saveToOfflineStorage()",id:"clientrecordsavetoofflinestorage",children:[],level:3},{value:"client.record.clearOfflineStorage(callback? | Promise)",id:"clientrecordclearofflinestoragecallback--promise",children:[],level:3}],level:2}],m={toc:s};function p(e){var t=e.components,a=(0,n.Z)(e,i);return(0,l.kt)("wrapper",(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"client.record")," gives you access to all methods related to data-sync."),(0,l.kt)("h2",{id:"prerequisite"},"Prerequisite"),(0,l.kt)("p",null,"You need to connect to the deepstream server:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"const { DeepstreamClient } = require('@deepstream/client')\nconst client = deepstream( 'localhost:6020')\nclient.login()\n")),(0,l.kt)("h2",{id:"methods"},"Methods"),(0,l.kt)("h3",{id:"clientrecordgetrecordname"},"client.record.getRecord(name)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"name"),(0,l.kt)("td",{parentName:"tr",align:null},"String"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The name of the record.")))),(0,l.kt)("p",null,"Retrieves and if necessary creates a ",(0,l.kt)("a",{parentName:"p",href:"datasync-record"},"Record")," with the given name. Records are persistent data structures that are synced between clients. To learn more about what they are used for and how they work, head over to the ",(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/datasync/records"},"record tutorial"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"const record = client.record.getRecord('user/johndoe')\n")),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"The record will be loaded asynchronously. To ensure the record is loaded put your logic into the ",(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/datasync/records#record-lifecycle"},"whenReady")," callback. However you can perform set operations without waiting for the record to be ready."))),(0,l.kt)("h3",{id:"clientrecordgetlistname"},"client.record.getList(name)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"name"),(0,l.kt)("td",{parentName:"tr",align:null},"String"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The name of the list.")))),(0,l.kt)("p",null,"Retrieves or creates a ",(0,l.kt)("a",{parentName:"p",href:"datasync-list"},"List")," with the given name. Lists are arrays of recordNames that clients can manipulate and observe. You can learn more about them in the ",(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/datasync/lists/"},"list tutorial"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},'const beatlesAlbums = client.record.getList(\'albums\')\nbeatlesAlbums.whenReady(() => {\n  console.log(beatlesAlbums.getEntries())\n})\n/*\n  [\n    "album/i9l0z34v-109vblpqddy",\n    "album/i9l0z3v4-ibrbp139rbr",\n    "album/i9l0z4d8-1w0p8xnk1sy"\n  ]\n*/\n')),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"The list will be loaded asynchronously. To ensure the list is loaded put your logic into the ",(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/datasync/records#record-lifecycle"},"whenReady")," callback."))),(0,l.kt)("h3",{id:"clientrecordgetanonymousrecord"},"client.record.getAnonymousRecord()"),(0,l.kt)("p",null,"Returns an ",(0,l.kt)("a",{parentName:"p",href:"datasync-anonymous-record"},"AnonymousRecord"),"."),(0,l.kt)("p",null,"An AnonymousRecord is a record that can change its name. It acts as a wrapper around an actual record that can be swapped out for another one whilst keeping all  bindings intact. You can learn more about anonymous records ",(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/datasync/anonymous-records/"},"here"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"const record = client.record.getAnonymousRecord()\nrecord.setName('user/johndoe')\nrecord.setName('user/maxpower')\n")),(0,l.kt)("h3",{id:"clientrecordnames"},"client.record.names()"),(0,l.kt)("p",null,"Returns all the available data-sync names."),(0,l.kt)("p",null,"Please note: Lists, AnonymousRecords and Records are all essentially the same thing within the SDK, so this array will contain a list of everything."),(0,l.kt)("p",null,"Due to how records work as well even after a discard this list will take a while to update. This is intentional as their is an option for how long a record will survive before being discarded! You can change that via the ",(0,l.kt)("inlineCode",{parentName:"p"},"recordDiscardTimeout: milliseconds")," option."),(0,l.kt)("h3",{id:"clientrecordhasname-callback--promise"},"client.record.has(name, callback | Promise)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"name"),(0,l.kt)("td",{parentName:"tr",align:null},"String"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The name of the record.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"callback"),(0,l.kt)("td",{parentName:"tr",align:null},"Function"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"Arguments are (String) error and (Boolean) hasRecord")))),(0,l.kt)("p",null,"The callback contains an error argument and a boolean to indicate whether or not the record exists in deepstream. This is useful to avoid creating a record via ",(0,l.kt)("inlineCode",{parentName:"p"},"getRecord( name )")," if you only want to edit the contents. The callback is invoked immediately if the record exists on the client."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"// Callback\nclient.record.has('user/johndoe', (error, hasRecord) => {\n  // ...\n})\n\n// Promise\ntry {\n  const hasRecord = await client.record.has('user/johndoe')\n  // ...\n} catch (error) {\n\n}\n")),(0,l.kt)("h3",{id:"clientrecordheadname-callback--promise"},"client.record.head(name, callback | Promise)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"name"),(0,l.kt)("td",{parentName:"tr",align:null},"String"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The name of the record.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"callback"),(0,l.kt)("td",{parentName:"tr",align:null},"Function"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"Arguments are (String) error and (Number) version")))),(0,l.kt)("p",null,"The callback contains an error argument and a number to indicate the current record version in deepstream."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"// Callback\nclient.record.head('user/johndoe', (error, version) => {\n  // ...\n})\n\n// Promise\ntry {\n  const recordVersion = await client.record.head('user/johndoe')\n  // ...\n} catch (error) {\n\n}\n")),(0,l.kt)("h3",{id:"clientrecordsnapshotname-callback--promise"},"client.record.snapshot(name, callback | Promise)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"name"),(0,l.kt)("td",{parentName:"tr",align:null},"String"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The name of the record.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"callback"),(0,l.kt)("td",{parentName:"tr",align:null},"Function"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"Arguments are (String) error and (Object) data")))),(0,l.kt)("p",null,"The callback contains the record's content without subscribing to updates. This can be used to avoid scenarios where you would request the record and discard it immediately afterwards. The callback is invoked immediately if the record data is already loaded and ready."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"// Callback\nclient.record.snapshot('user/johndoe', (error, data) => {\n    // ...\n})\n\n// Promise\ntry {\n  const data = await client.record.snapshot('user/johndoe')\n} catch (error) {\n\n}\n")),(0,l.kt)("h3",{id:"clientrecordsetdataname-path-data-callback"},"client.record.setData(name, path, data, callback)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"name"),(0,l.kt)("td",{parentName:"tr",align:null},"String"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The name of the record.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"path"),(0,l.kt)("td",{parentName:"tr",align:null},"String"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"The path of the record to set data.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"data"),(0,l.kt)("td",{parentName:"tr",align:null},"Various"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The data to set on the record.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"callback"),(0,l.kt)("td",{parentName:"tr",align:null},"Function"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"Arguments are (String) error")))),(0,l.kt)("p",null,"An upsert operation that allows updating of a record without being subscribed to it. If the record does not exist deepstream will try and permission the request to create the record. The callback if provided will be called with any errors that occurred while writing to the record."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"// Set the entire record's data - record will be created if it doesn't exist\nclient.record.setData('user/homer', { status: 'married' })\n\n// Update only marriage status\nrecord.set('user/homer', 'status', 'single')\n\n// Set the entire record's data with write acknowledgement\nclient.record.setData('user/homer', { status: 'married' }, (error) => {\n  // ...\n})\n\n// Update only a property with write acknowledgement\nclient.record.setData('user/homer', 'son', 'Bart', (err) => {\n  // ...\n})\n")),(0,l.kt)("h3",{id:"clientrecordsetdatawithackname-path-data"},"client.record.setDataWithAck(name, path, data)"),(0,l.kt)("p",null,"The same as ",(0,l.kt)("inlineCode",{parentName:"p"},"setData")," but returns a Promise."),(0,l.kt)("h3",{id:"clientrecordlistenpattern-callback"},"client.record.listen(pattern, callback)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pattern"),(0,l.kt)("td",{parentName:"tr",align:null},"String (regex)"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The pattern to match records which subscription status you want to be informed of")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"callback"),(0,l.kt)("td",{parentName:"tr",align:null},"Function"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"A function that will be called whenever a record matching the ",(0,l.kt)("inlineCode",{parentName:"td"},"pattern")," has been initially subscribed to. When there are no more subscriptions to any records matching ",(0,l.kt)("inlineCode",{parentName:"td"},"pattern"),", the callback passed to ",(0,l.kt)("inlineCode",{parentName:"td"},"response.onStop()")," is called. Arguments are (String) match, and response (Object).")))),(0,l.kt)("p",null,'Allows to listen for record subscriptions made by other clients. This is useful to create "active" data providers, e.g. providers that only provide data for records that users are actually interested in. You can find more about listening in the ',(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/datasync/records/"},"record tutorial"),"."),(0,l.kt)("p",null,"The callback is invoked with three arguments:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"match"),": The name of the record that has been matched against the provided pattern"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"response"),": contains two functions (",(0,l.kt)("inlineCode",{parentName:"li"},"accept")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"reject"),"), one of them needs to be called")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"client.record.listen('raceHorse/.*', (match, response) => {\n  // see tutorial for more details\n})\n")),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"The callback will be called for all matching subscriptions that already exist at the time its registered."))),(0,l.kt)("h3",{id:"clientrecordunlistenpattern"},"client.record.unlisten(pattern)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pattern"),(0,l.kt)("td",{parentName:"tr",align:null},"String (regex)"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The previously registered pattern")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"client.record.unlisten('raceHorse/.*')\n")),(0,l.kt)("p",null,"Removes a listener that was previously registered using ",(0,l.kt)("inlineCode",{parentName:"p"},"listen()"),"."),(0,l.kt)("h3",{id:"clientrecordnotifyrecordnames-callback--promise"},"client.record.notify(recordNames, callback? | Promise)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recordNames"),(0,l.kt)("td",{parentName:"tr",align:null},"Array"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The record names to be notified of data changes")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"callback"),(0,l.kt)("td",{parentName:"tr",align:null},"Function"),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"Arguments are (String) error")))),(0,l.kt)("p",null,"Notify that the record data was changed at the database without using deepstream APIs. Useful for third party integrations."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"client.record.notify(['raceHorse', 'pony'], (error) => {\n  // ...\n})\n\n// Promise\ntry {\n  const data = await client.record.notify(['raceHorse', 'pony'])\n} catch (error) {\n  // ...\n}\n")),(0,l.kt)("h3",{id:"clientrecordsetmergestrategy-recordname-mergestrategy"},"client.record.setMergeStrategy (recordName, mergeStrategy)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"recordName"),(0,l.kt)("td",{parentName:"tr",align:null},"String"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The record name merge strategy to be changed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mergeStrategy"),(0,l.kt)("td",{parentName:"tr",align:null},"Function"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"Merge strategy to be set for the record")))),(0,l.kt)("p",null,"Set merge strategy for a given record. See ",(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/datasync/handling-data-conflicts"},"handling data conflicts")," for more information."),(0,l.kt)("h3",{id:"clientrecordsetmergestrategyregexp-pattern-mergestrategy"},"client.record.setMergeStrategyRegExp (pattern, mergeStrategy)"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Argument"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Optional"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"pattern"),(0,l.kt)("td",{parentName:"tr",align:null},"String(regex)"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"The reg exp to match record names for which the merge strategy is to be changed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"mergeStrategy"),(0,l.kt)("td",{parentName:"tr",align:null},"Function"),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"Merge strategy to be set for the records")))),(0,l.kt)("p",null,"Set merge strategy for a given record. See ",(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/datasync/handling-data-conflicts"},"handling data conflicts")," for more information."),(0,l.kt)("h3",{id:"clientrecordsavetoofflinestorage"},"client.record.saveToOfflineStorage()"),(0,l.kt)("p",null,"Save all records in memory to offline storage"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"client.record.saveToOfflineStorage()\n")),(0,l.kt)("h3",{id:"clientrecordclearofflinestoragecallback--promise"},"client.record.clearOfflineStorage(callback? | Promise)"),(0,l.kt)("p",null,"Clears offline storage data"))}p.isMDXComponent=!0}}]);